;; SPDX-License-Identifier: PMPL-1.0-or-later
;; META.scm - Project metadata and architectural decisions for Axiom.jl

(define project-meta
  `((version . "1.0.0")
    (architecture-decisions
      ((adr-001 . ((title . "Multi-backend architecture via AbstractBackend dispatch")
                   (status . "accepted")
                   (context . "ML ops need to run on CPU, GPU, and accelerators with different performance profiles")
                   (decision . "Define AbstractBackend type hierarchy with JuliaBackend as default, ZigBackend/CUDABackend/ROCmBackend/MetalBackend as alternatives. Global backend switchable via set_backend!. Julia backend is always the reference implementation.")
                   (consequences . "Each backend must implement the full ops interface. Fallback to Julia when native backend unavailable.")))
       (adr-002 . ((title . "Zig as sole native backend for all compute kernels")
                   (status . "accepted")
                   (context . "Need high-performance native backend. Zig provides SIMD, parallelism, and C ABI compatibility without a separate toolchain.")
                   (decision . "Zig backend handles all native ops: parallel matmul/conv as well as element-wise SIMD ops (activations, normalization). Exposes C ABI via FFI as libaxiom_zig. Rust backend removed.")
                   (consequences . "Single native codebase to maintain. Julia ccall bindings for Zig only. Users must compile libaxiom_zig.so from source.")))
       (adr-003 . ((title . "GPU backends as Julia package extensions")
                   (status . "accepted")
                   (context . "GPU packages (CUDA.jl, AMDGPU.jl, Metal.jl) are heavy dependencies that most users don't need")
                   (decision . "Use Julia's package extension mechanism. GPU backends defined in ext/ and loaded conditionally when user imports CUDA/AMDGPU/Metal.")
                   (consequences . "Clean dependency tree. GPU ops only available when user explicitly loads GPU package.")))
       (adr-004 . ((title . "SMT-based formal verification via @prove macro")
                   (status . "accepted-but-disabled")
                   (context . "Core value proposition is provably correct ML. Need formal property verification.")
                   (decision . "Bundled SMTLib.jl package provides solver interface. @prove macro translates Julia properties to SMT-LIB2 and checks against Z3/CVC5/Yices/MathSAT.")
                   (consequences . "@prove currently disabled due to weak dependency import ordering. Needs refactor to package extension pattern.")))
       (adr-005 . ((title . "Proof certificates with SHA256 integrity")
                   (status . "accepted")
                   (context . "Verification results must be serializable and verifiable by third parties")
                   (decision . "ProofCertificate struct with SHA256 hash. Serialize/deserialize to JSON. Export stubs to Lean 4, Coq, Isabelle/HOL for external verification.")
                   (consequences . "Current export generates sorry/Admitted placeholders. Real proof translation is future work.")))
       (adr-006 . ((title . "PyTorch interoperability via PyCall extension")
                   (status . "accepted")
                   (context . "Most existing ML models are in PyTorch. Need import path for verification.")
                   (decision . "AxiomPyTorchExt provides bidirectional conversion (Dense, Conv2d, BatchNorm, activations). State dict parsing for weight transfer.")
                   (consequences . "Depends on PyCall.jl and user's Python/PyTorch installation. HuggingFace model-specific converters still needed.")))
       (adr-007 . ((title . "Coprocessor dispatch with self-healing fallback")
                   (status . "accepted")
                   (context . "Need to support 9 accelerator types (TPU, NPU, DSP, PPU, Math, FPGA, VPU, QPU, Crypto) beyond GPU backends, with graceful degradation when hardware unavailable.")
                   (decision . "CoprocessorBackend union type with environment-variable-based detection (AXIOM_*_AVAILABLE, AXIOM_*_DEVICE_COUNT). Self-healing fallback to JuliaBackend with runtime diagnostics. Strict mode (AXIOM_*_REQUIRED=1) prevents fallback for safety-critical deployments. Shared infrastructure across 14 packages via abstract.jl template.")
                   (consequences . "Extension hooks are stubs until vendor SDKs integrated. 13 sibling packages share identical infrastructure pattern with domain-specific operation hooks.")))))
    (development-practices
      ((code-style . "julian")
       (security . "openssf-scorecard")
       (versioning . "semver")
       (documentation . "asciidoc")
       (branching . "trunk-based")
       (testing . "julia-test-stdlib")
       (license . "PMPL-1.0-or-later")))
    (design-rationale
      ((why-julia . "First-class support for scientific computing, multiple dispatch enables clean backend abstraction, metaprogramming for @axiom/@ensure/@prove macros, strong numerics ecosystem")
       (why-not-flux . "Flux.jl is excellent but doesn't provide formal verification. Axiom.jl's value is the proof layer, not the tensor ops.")
       (why-smt . "SMT solvers provide decidable fragments of first-order logic. Properties like 'softmax sums to 1' and 'relu output >= 0' are directly expressible in SMT-LIB2.")))))
